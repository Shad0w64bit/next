Приоритеные:
 • добавить базовые типы и их компиляцию
 • добавить структуры и их компиляцию
 • добавить вычисления выражения согласно польской записи
https://www.youtube.com/watch?v=Vk-tGND2bfc


Обычные:
 • добавить директивы конфигурации
директива ключ=значение
#[env: gui]
директива модуля
#[modulename(arg1, arg2, arg3)]

 
 • Добавить обработчик ошибок (запоминать в парсере номер строки каждой команды и показывать его при ошибке)

 • Обработка кастомных структур регулярными выражениями.
Обычная регулярка:
in: "test123 string"		out: (\w)(\d).*
Обработка лексем:

Identifier	MessageBox
LeftParen	(
Number		0
Comma		,
String		Hello World!
Comma		,
String		MyApp
Comma		,
Number		64
RightParen	)

\( - LeftParen
\) - RightParen
I - Identifier
\d - Number
\w - String
, - Comma

Out: (I) \( \s* (?: (I|\d|\w) ,? \s* )* \)



 • Графы
Специальные функции с конечным числом состояний
q0 
	\w\d > q1 {atext}
q1 
	\w\d > q1 {atext}
	.	 > q2
	@	 > q3
q2
	\w\d > q1 {atext}
q3 
	\w\d > q4 {alnum}
q4
	\w\d > q4 {alnum}
	.-	 > q5 {alnum}
	EOL  > q6
q5
	\w\d > q4 {alnum}
	-	 > q5 {alnum}
q6
	END
	
 • Потоковая обработка информации
Например сжатие и извлечение текста не лету
gzip > text, tar > gzip > text, data > encoding, decoding > data

 • Сборщики данных
Данные могут быть представлены в удобных для них представлениях. Например в виде таблиц A,B,C. Но при сереализации данные должные быть собраны в единую стуктуру за O(n). Думаю собрать один раз socket-пакет из разнородных данных будет быстрее, чем резервировать место, и постоянно перегонять части структуры в данные которые должны быть отправлены. Тесно связано со следующим пунктом.

 • Связные таблицы (структуры)
Часто нужно что бы части одной структуры зависили от другой. Например при создании exe файла, нужно указать размер секций в файле, или общий размер файла, что можно сделать только когда все данные будут подготовленны. 

Думаю нужно указать некоторое правило для сборки таких структур. С одной стороны сборка будет происходить неявно, что плохо. Лучше когда есть отдельная функция которая все считает и собирает в единый пакет. Но с другой стороны, мы избавляемся от необходимости наличия этой функции. А все правила сборки описываем при создании структуры.

struct Header {
	title: str
	data: *ByteArray
	len: u32
}

{
	// Init
	head: Header {
		len => sizeof(self.data)
	}
	// something operations 
	
	head.title = "String"
	head.data = ("Test").ToByteArray();
	
	// Build and Send Package
	(head).Serialize();
	
}